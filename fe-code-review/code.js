// FIXME: in express you have to call `next(error)` for async code that can throw an error in order to handle errors properly. See https://expressjs.com/en/guide/error-handling.html
app.post('/api/extract', upload.single('file'), async (req, res) => {
    // FIXME: you could put route path into a variable and use it here as well in case it ever changes
    logInfo('POST /api/extract',req.body);
    // FIXME: please run a formatter to keep the code style consistent
    logInfo('FILE=',req.file);

    // FIXME: to keep code more readable avoid unnecessary nesting and use early returns
    if (req.body) {
        const file = req.file;
        // FIXME: (optional as I don't know the stack) request ID is usually generated by a middleware and it doesn't come from the client
        const requestID = req.body.requestID;
        const project = req.body.project;
        // FIXME: `userID` would be a better name and consistent with `requestID`
        const idUser = req.body.userID;
        const user = await User.findOne(idUser);

        // FIXME: you could extract and improve request validation in separate function or middleware
        if (requestID && project && idUser && user) {
            logDebug('User with role '+user.role, user);
            // FIXME: I suggest extracting "ADVISOR" to a variable
            // FIXME: you could use .includes() instead
            if (user.role === 'ADVISOR' || user.role.indexOf('ADVISOR') > -1)
                // FIXME: inconsistent approach to single line if statements - always adding {} can make your life easier if you'll ever have to modify or debug this code
                return res.json({requestID, step: 999, status: 'DONE', message: 'Nothing to do for ADVISOR role'});

            /* reset status variables */
            // FIXME: updateStatus function is really confusing and you always provide "" as last parameter. You could utilize default parameters and enums to make it more clear for reader
            await db.updateStatus(requestID, 1, '');

            logDebug('CONFIG:', config.projects);
            if (project === 'inkasso' && config.projects.hasOwnProperty(project) && file) {
                // FIXME: `hasSum` is unused
                const hashSum = crypto.createHash('sha256');
                const fileHash = idUser;
                const fileName = 'fullmakt';
                const fileType = mime.getExtension(file.mimetype);
                if (fileType !== 'pdf')
                    // FIXME: you could create two functions that return response objects to keep success/error responses consistent
                    return res.status(500).json({requestID, message: 'Missing pdf file'});
                await db.updateStatus(requestID, 3, '');

                const folder = `${project}-signed/${idUser}`;
                logDebug('FILE2=', file);
                // FIXME: you could speed things up using Promise.all()/Promise.allSettled() here (unless there are some waterfalls in the background, then please ignore this comment)
                await uploadToGCSExact(folder, fileHash, fileName, fileType, file.mimetype, file.buffer);
                await db.updateStatus(requestID, 4, '');
                const ret = await db.updateUploadedDocs(idUser, requestID, fileName, fileType, file.buffer);
                logDebug('DB UPLOAD:', ret);

                await db.updateStatus(requestID, 5, '');

                // FIXME: `sent` is unused
                let sent = true;
                const debtCollectors = await db.getDebtCollectors();
                logDebug('debtCollectors=', debtCollectors);
                if (!debtCollectors)
                    // FIXME: (personal/project style preference) - `return res.json()` is misleading as it suggests that something is done with the return value of `.json()`. I suggest refactoring those into `res.json(); \n return;`
                    return res.status(500).json({requestID, message: 'Failed to get debt collectors'});

                // FIXME: please finish implementation and remove your TODOs/fixes before CR
                if (!!(await db.hasUserRequestKey(idUser))) { //FIX: check age, not only if there's a request or not
                    return res.json({requestID, step: 999, status: 'DONE', message: 'Emails already sent'});
                }

                const sentStatus = {};
                for (let i = 0; i < debtCollectors.length ; i++) {
                    await db.updateStatus(requestID, 10+i, '');
                    // FIXME: you could make your life easier using destructuring - `const {a, b, c} = d[i];`
                    // FIXME: `collectorID` would be a better name and consistent with `requestID`
                    const idCollector = debtCollectors[i].id;
                    const collectorName = debtCollectors[i].name;
                    const collectorEmail = debtCollectors[i].email;
                    const hashSum = crypto.createHash('sha256');
                    // FIXME: you could declare the date outside of the loop to avoid creating it every iteration
                    const hashInput = `${idUser}-${idCollector}-${(new Date()).toISOString()}`;
                    logDebug('hashInput=', hashInput);
                    hashSum.update(hashInput);
                    const requestKey = hashSum.digest('hex');
                    logDebug('REQUEST KEY:', requestKey);

                    const hash = Buffer.from(`${idUser}__${idCollector}`, 'utf8').toString('base64')

                    if (!!(await db.setUserRequestKey(requestKey, idUser))
                        && !!(await db.setUserCollectorRequestKey(requestKey, idUser, idCollector))) {

                        /* prepare email */
                        // FIXME: you could create a separate function for creating config object
                        const sendConfig = {
                            sender: config.projects[project].email.sender,
                            replyTo: config.projects[project].email.replyTo,
                            // FIXME: unterminated strings
                            subject: 'Email subject,
                            templateId: config.projects[project].email.template.collector,
                            params: {
                                downloadUrl: `https://url.go/download?requestKey=${requestKey}&hash=${hash}`,
                                uploadUrl: `https://url.go/upload?requestKey=${requestKey}&hash=${hash}`,
                                confirmUrl: `https://url.go/confirm?requestKey=${requestKey}&hash=${hash}`
                            },
                            tags: ['request'],
                            to: [{ email: collectorEmail , name: collectorName }],
                        };
                        logDebug('Send config:', sendConfig);

                        try {
                            await db.setEmailLog({collectorEmail, idCollector, idUser, requestKey})
                        } catch (e) {
                            logDebug('extract() setEmailLog error=', e);
                        }

                        /* send email */
                        const resp = await email.send(sendConfig, config.projects[project].email.apiKey);
                        logDebug('extract() resp=', resp);

                        // update DB with result
                        await db.setUserCollectorRequestKeyRes(requestKey, idUser, idCollector, resp);

                        if (!sentStatus[collectorName])
                            sentStatus[collectorName] = {};
                        sentStatus[collectorName][collectorEmail] = resp;

                        if (!resp) {
                            logError('extract() Sending email failed: ', resp);
                        }
                    }
                }
                await db.updateStatus(requestID, 100, '');

                logDebug('FINAL SENT STATUS:');
                // FIXME: you probably don't want this console.dir call
                console.dir(sentStatus, {depth: null});

                // FIXME: please remove commented out code if it serves no purpose
                //if (!allSent)
                //return res.status(500).json({requestID, message: 'Failed sending email'});

                await db.updateStatus(requestID, 500, '');

                // FIXME: separating this into a function would make this comment redudant. Also this config is used only in `logDebug`
                /* prepare summary email */
                const summaryConfig = {
                    // FIXME: please remove commented out code if it serves no purpose
                    //bcc: [{ email: 'tomas@inkassoregisteret.com', name: 'Tomas' }],
                    sender: config.projects[project].email.sender,
                    replyTo: config.projects[project].email.replyTo,
                    subject: 'Oppsummering KravsforespÃ¸rsel',
                    templateId: config.projects[project].email.template.summary,
                    params: {
                        collectors: sentStatus,
                    },
                    tags: ['summary'],
                    // FIXME: please finish implementation and remove your TODOs/fixes before CR
                    to: [{ email: 'tomas@upscore.no' , name: 'Tomas' }], // FIXXX: config.projects[project].email.sender
                };
                logDebug('Summary config:', summaryConfig);

                // FIXME: please remove commented out code if it serves no purpose
                /* send email */
                //const respSummary = await email.send(sendConfig, config.projects[project].email.apiKey);
                //logDebug('extract() summary resp=', respSummary);

                await db.updateStatus(requestID, 900, '');
            }
            await db.updateStatus(requestID, 999, '');
            // FIXME: sending emails is done in if statement above so this code is not aware if they were sent correctly
            return res.json({requestID, step: 999, status: 'DONE', message: 'Done sending emails...'});
        } else
            // FIXME: typo in "required"
            return res.status(500).json({requestID, message: 'Missing requried input (requestID, project, file)'});
    }
    // FIXME: typo in "required"
    res.status(500).json({requestID: '', message: 'Missing requried input (form data)'});
});
